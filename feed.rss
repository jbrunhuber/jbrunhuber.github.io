<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Joshtastic</title><description>A description of Joshtastic</description><link>https://your-website-url.com</link><language>en</language><lastBuildDate>Sat, 30 Jan 2021 15:46:23 +0100</lastBuildDate><pubDate>Sat, 30 Jan 2021 15:46:23 +0100</pubDate><ttl>250</ttl><atom:link href="https://your-website-url.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://your-website-url.com/posts/first-post</guid><title>Frameworks and Libraries in Swift</title><description>A description of my first post.</description><link>https://your-website-url.com/posts/first-post</link><pubDate>Sat, 30 Jan 2021 15:44:00 +0100</pubDate><content:encoded><![CDATA[<h1>Frameworks and Libraries in Swift</h1><p>I like splitting code into smaller frameworks. This keeps even larger and complex codebases maintainable. And I also like making reusable parts open source so I can share them between projects and maybe someone other will find it useful later too. I really like the approach by John Sundell https://twitter.com/johnsundell/status/1083794539486371841 But the important question is: What is actually a “framework”? Xcode asks me every time if I want to create a “Cocoa Touch Framework” or a “Cocoa Touch Static Library”.</p><h2>Frameworks vs. Static Libraries</h2><p>Basically, there are two types of libraries: Static and dynamic libraries. This also applies to ObjectiveC, C++ and other programming languages. When you build your code, it will compiled into “object files”. Object files contain the executable machine code and also some other information used by the linker (symbols like constants, function calls, ...). The linker puts all of these object files together and creates an executable binary. If you want to separate your code in smaller “parts” as libraries or frameworks you have two options: A <em>static</em> library or a <em>dynamic</em> framework. The difference lies in the linking process. <em>Statically</em> linked files are included into the binary. That means your binary file will be larger. More data have to be loaded into the memory when you launch the App, so your App takes longer to start. Function calls however are faster than in shared libraries. In <em>dynamic</em> linking, the files will be shared and loaded at runtime. The binary file size will be smaller and the launch time is a little faster. Dynamic libraries can be used by multiple applications while static libraries have to be linked into each binary. Another important thing to mention is that frameworks can contain Assets (xibs, Fonts, Images, ...) while static touch libraries are restricted to code only.</p><p><em>Sum up:</em> <em> Static libraries cause slower launch times because of a larger binary file size </em> Frameworks can contain Assets whereas static libraries just contain code</p><h2>Integration of libraries and frameworks in your projects</h2><p>There are two options how to integrate a framework or library into your project. 1. Use a Package-Manager like CocoaPods which will clone the source code. When you compile your workspace, your code <em>and</em> the framework/library will compiled. 2. You can also include precompiled frameworks or libraries into your project. In order to test your App in Simulator you have to make sure that it’s a so called <em>fat framework/library</em>. It contains machine code for arm (your iPhone) and x86 (Simulator).</p><p>The second option is more complex and require some shell scripting afford. A good read about this topic is this: https://jobs.zalando.com/tech/blog/how-the-zalando-ios-app-abandoned-cocoapods-and-reduced-build-time/. But the benefit is that you don’t need to rebuild all included libraries/frameworks and haven’t rely on a Cocoapods workspace. The downside is that you have to update your dependencies manually while Cocoapods does this step for you.</p><h2>How about the Swift library?</h2><p>The standard library contains all fundamental stuff we use every day (types like String or Int, collections like Array, ...). Typically, those libraries will be included into the system (like in ObjectiveC). Swift is a relatively new language with major changes in the last years so the standard library is not considered as “stable” because the calls on binary level (ABI) differ from each swift version.</p><h2>What is an “Application Binary Interface”</h2><p>You may know what an “Application Programming Interface - API” is. A simple example is a Weather API from a website. The call of the interface is clearly described like this /weather-rest/zipcode/. You have to rely to the scheme otherwise you’ll get a bad response. The same applies to function calls in libraries. You have to pass the required parameters with the right types in the correct order. Otherwise it won’t work. How the function-call should look like is specified into <em>module maps</em>. They tell Xcode which parameters are required. So the module maps are the API description to a library. When your code and library is compiled, there is no source code information anymore. The function call now have to match the interface on a compiled level. This is called the “binary interface”.</p><h2>ABI Stability</h2><p>Let’s go back to our weather API. The definition is /weather-rest/zipcode/. And we have an amazingly fast backend so everyone is using our APIs. Now let’s take an attempt to optimize it by changing the call to /weather/zipcode. It’s cleaner and shorter. But all existing clients still have the old scheme configured and will run into a failure. In order to prevent that, we have to make sure our API is <em>backwards compatible</em>. The new clients can call the new API but we have to leave the old scheme open for the older clients. Maybe forever. The same applies to our compiled libraries again and also the swift library. ABI stability means that the old binary can be replaced by a newer one without causing problems. Swift isn’t “ABI-Stable” so it’s copied in every App. I don’t know which technology Apple uses for their Apps but assume the Music app is built with Swift 4.1 while the Weather App is built with Swift 2.1. Both versions of Swift are incompatible to each other but we can run them both because the Swift library is included in each app. If Apple put the Swift library into the OS, they have to ensure that everything is backwards compatible. This isn’t easy because Swift is a young and rapidly changing language. Large language changes become much harder in future when Swift gets a stable ABI. The main objective of Swift 5 is to ensure this stability and its backwards compatibility. Swift 5 is going to be released early this year so we need have to be patient for a little time :)</p><h2>Conclusion</h2><p>In our everyday iOS Developer lives we usually don’t get in touch with linking and compiling. But I find it important to know what’s going on under the hood. The day will come when you get a linker error and now you know what’s happening :)</p>]]></content:encoded></item></channel></rss>